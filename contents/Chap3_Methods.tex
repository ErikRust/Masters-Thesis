\chapter{Methodology} \label{Methodology}
\label{chp:3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Biological models, constructed by identification and description of structures and reaction processes. For example stoichiometry, interaction mechanisms, reaction rates, rate constants and various other parameters. These descriptive properties are encapsulated in mathematical formalism that we name a biological model. Most models in systems biology obtain parameter values from experimental data, giving the model some degree of physiological relevance. 
Once a model has been created and validated it can be transcribed into \gls{sbml} and stored on-line in biological model repositories such as \href{https://www.ebi.ac.uk/biomodels-main/}{BioModels} and \href{https://jjj.bio.vu.nl}{JWSOnline}. These model repositories give rise to interesting possibilities as the biological models are available to all, and can be interrogated and analyzed by any method of the researcher's choice. This investigation leverages the advantages of computational platforms to perform an analysis accross these models. 

Biological model analysis platforms range from stand-alone applications such as Jarnac, COPASI, CellDesigner and BioNetGen. Further tools are available in the form of add-on modules and libraries like LibRoadRunner, COBRA, Pysces, SimBiology and Simulink for the Python and Matlab scripting languages respectively \cite{Sauro2000, Hoops2006, Olivier2005, Somogyi2015, Harris2016, Laurent2017}. Websites such as JWSOnline, provides an interactive interface for model creation, curation and simulation. A task is achieved by utilizing custom Mathematica model manipulation packages alongside a combination of the above mentioned components as is described by \cite{Olivier2004, jwsdocs}. The JWSOnline platform is specifically mentioned here as this will form as a basis of tools, as described in section \ref{Working Environment} and \ref{Scripting in Mathematica}. 

With such an abundance of analysis platforms, the problem at hand became one of best choice for application. Therefore a clear working environment was defined as follows. 

\section{Setting up the Working environment} \label{Working Environment}

The working environment was contructed in two parts: A data management component, responsible for storing and translating models, as well as an scripting language, responsible for automation of operations required. Mathematica v11 fulfilled this need of scripting language, as is described in section \ref{Scripting in Mathematica}. The data management portion was handled by a local instance of \href{https://jjj.bio.vu.nl}{JWSOnline}, hosted through the Docker platform as is discussed in \ref{Docker Installation}. 

Docker, an open source platform acting as an host for an application, had the advantage of being platform agnostic, independent of the host operating system. As such a Docker environment is self contained and easily reproducible, an advantage and requirement towards scientific inquiry. The aim of this locally hosted \href{https://jjj.bio.vu.nl}{JWSOnline} server was to achieve a form of isolation from active production servers. This was done as to not inundate active servers with the repetitive model upload, download, query and conversion operations. This proved especially useful considering the repetitive nature associated with the development and testing cycle of thousands of models. An added benefit of this isolation was an increase in overall efficiency. This was due to internet connection speed and availability affecting only the initial retrieval of models from public servers. Overhead communication rates, between Mathematica and the server instance, was limited only by processor transfer rates. As such an increase in calculation speeds were observed. 

The following section is a description of the basic installation protocol followed in order to set up the local environment. For a more complete JWSOnline docker installation guide please refer to the documentation, available at \href{http://jws-docs.readthedocs.io/10_docker.html#building-the-jws-online-docker-image}.


\subsection{JWSOnline and Docker installation} \label{Docker Installation}

The Docker host application was downloaded and installed for the operating system in question (OSX), as instructed by the docker documentation available at \href{http://docker-sean.readthedocs.io}{http://docker-sean.readthedocs.io}. The JWSOnline Docker compose script, located at \href{http://jws-docs.readthedocs.io/10_docker.html#building-the-jws-online-docker-image} was copied and saved into a local file named "docker-compose.yml", noting the working directory. More information on the ".yml" format and the docker compose file in general can be obtained at \href{https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples} as a deeper description is outside of the scope of this thesis. 
Environment variables such as passwords and volume names in the "docker-compose.yml" had to be altered and saved to user specific requirements. This would be individual specific and other than the need for authentication the choice of these variables has no appreciable impact on further operations. Afterwards the images and services defined could be retrieved through running the command "docker-compose pull" from within a terminal/bash environment (Please note this command must be performed from within the working directory noted earlier). The retrieved services were then launched by the "docker-compose up" command. This command starts the services as defined by the "docker-compose.yml" file. A successful installation and start up was confirmed by visiting the local host or loop back IP address (127.0.0.1) and being greeted by our own local JWSOnline homepage.

As mentioned earlier, the local JWSOnline installation provided the model handling portion of the working environment and as such needed to be able to communicate with the scripting language at hand, ie. Mathematica. The communications method native to JWSOnline, is the representational state transfer (REST) application program interface (API). As this is the basis of data transfer, the following section will provide a brief overview of example constructs, with specifics handled as applicable to the algorithm detailed in section \ref{Scripting in Mathematica}. This communications protocol allows applications and programs to share information with one another through a standardized method. Various \gls{api} methods exist, but for the sake of simplicity the focus of this discussion will rest on the RESTFull web service framework as is applicable to the investigation at hand. 

\subsection{Communicating with JWSOnline via the \gls{rest} \gls{api}} \label{REST Communication}

From a server perspective the \gls{rest} framework enables the control of access to internal application resources, while maintaining open access to services made available by such applications. These service endpoints are accessible to a client in the form of a basic URL request. This request uses the hypertext transfer protocol (HTTP) as is familiar from all generic web browsers. The REST framework was specifically developed in this way as to simplify the development process. Various applications can communicate with one another in a uniform manner \cite{rest2018}. Case and point, the availability of the \href{http://jjj.biochem.sun.ac.za}{JWSOnline} \gls{api} enabled the interaction of the web server with other applications or compute platforms, thus expanding the use of the application outside of the original project scope. 

HTTP requests can take on many forms, however for the purpose of this study the constructs will be fairly similar. For instance, one such example can take on the following form; \href{http://jjj.biochem.sun.ac.za/rest/models/teusink/mf}{http://jjj.biochem.sun.ac.za/rest/models/teusink/mf}. Various parts was interactively altered, as described in section \ref{Scripting in Mathematica}, in an attempt at an automated model handling algorithm. Let us therefore investigate and build upon this request. As is indicated by the "HTTP://" portion, this request utilizes the hypertext transport protocol (HTTP) at host address \href{jjj.biochem.sun.ac.za}{jjj.biochem.sun.ac.za}. The request is directed at the \gls{rest} endpoint within the "/models" directory to return the "/teusink" model in an "/mf" format. The returned result is a JSON data pair with model name and data contents as the first and second respective entries.

This example request above can be altered to return models based on specified criteria. For example, metabolic models can be returned by altering the request construct as follow; \href{http://jjj.biochem.sun.ac.za/rest/models/?id=&organism=&process=1&jwsmodel__model_type=}{\nolinkurl{http://jjj.biochem.sun.ac.za/rest/models/?id=\&organism=\&process=1\&jwsmodel\_\_model\_type=}}. In this request, "process=1" refers to models fulfilling the prerequisite of containing metabolic processes as defined by annotations from model creation and curation stages. A different one of these endpoints enabled the integration of models from an external source, to within the JWSOnline database. This proved useful in obtaining a larger sample size, as the \href{https://www.ebi.ac.uk/biomodels-main/}{BioModels} repository was consulted and integrated as described in section \ref{Scripting in Mathematica}. For more on JWSOnline specific REST endpoints, please refer to the JWSOnline documentation \cite{jwsdocs}. 

The protocols and endpoints discussed above, proved useful in single isolated instances, however, when paired with a scripting language, they become immensely powerful and endlessly useful. Operations could be performed faster, more accurately and for longer continuous time periods than would otherwise be possible by a human mind. The following section is therefore dedicated to the introduction and explanation of the individual steps leading to the entirety of the automated model interrogation algorithm. This algorithm was responsible for the collection of data utilized for the analysis as described by section \ref{Analysis}.

\section{Scripting in Mathematica} \label{Scripting in Mathematica}

For the sake of simplicity and transparency, compute operations were organized into three classes namely, retrieval, sorting and calculations as presented in figure \ref{dataFlow}. The Teusink model of glycolysis was used throughout as initial testing model. As such, the same model will be used here in order to demonstrate the protocols for a single sample. 

\begin{figure}[p] \label{dataFlow}
\includegraphics[width=1\textwidth]{Algorithm}
\centering
\caption{Diagram of algorithm indicating the flow of execution}
\label{fig:Algorithm}
\end{figure}

\subsection{Retrieval (A)} \label{Retrieval}
The JWSOnline API provided an endpoint for model retrieval from remote sources. The URL interaction functions of Mathematica, namely HTTPRequest and URLExecute, was used to construct a list of URLs linking to SBML models in both JWSOnline as well as Biomodels. The relevant remote parts of the example URL construct (\href{http://jjj.bio.vu.nl/rest/fetch/?type={type}&redirect={redirect}&remote={remote}}) was replaced by the remote URL's from the list created above. This command, initiated from the local JWSOnline instance, sequentially imported and converted each model to an internal data format. These models were then available to retrieve in any of the formats supported by JWSOnline. This raised the question of which model format would be best suited for the investigation at hand. The discussion of which continues in the following section.

\subsubsection{Model Format and Translation} \label{Translation}
The development of an automated algorithm for metabolic model analysis required a specific model format. The format had to be generic enough to facilitate the development of unattended automated functions, yet flexible enough to uniformly handle differences among models from various origins, destined for a diverse range of uses. As such five key aspects were identified as criteria for a suitable model format.

The model format had to: 
\begin{enumerate} \label{modelFormat}
  \item Consistently store similar data type at the same index - predictability
  \item Be easily understood by both humans and computers alike - ease of development
  \item Impart all of the information stored within the original model - consistency
  \item Keep information uniformly organized - accuracy
  \item Allow for direct computational interaction - accessibility
\end{enumerate}

\gls{sbml} provides a standardized structure to which biological models are kept. As such it seemed a logical first choice, however, although \gls{sbml} meets many of the requirements such as, predictability, accuracy and consistency, it does not meet all. \gls{sbml} makes complete sense to a computer, yet the syntax has a steep learning curve for the human eye. Combined with the fact that no native Mathematica \gls{sbml} parsing was supported at the time of development, the ease of development and accessibility aspects proved problematic. Therefore a method of model translation was called for. 

This action was achieved through the use of \href{https://jjj.bio.vu.nl}{JWSOnline}, whereby a \gls{sbml} model was retrieved from a remote server, converted and made available in matrix format (\gls{mf}) (One of the native JWSOnline data formats). This format was chosen as it fulfilled all of the criteria as set out in list \ref{modelFormat}. This format had the added advantage of enabling metabolic control calculations as discussed in section \ref{Calculations} to be done via matrix methods as described by \citeauthor{Hofmeyr2001}

\begin{figure}[p]
\includegraphics[width=1\textwidth]{MatrixFormat}
\centering
\caption{A graph representation of the Matrix Format (MF). Edge labels represent list index numbers and vertex labels denote content.}
\label{fig:MatrixFormat}
\end{figure}

In \gls{mf}, data is organized by content type. For example; rate-equations, metabolites, stoichiometry, parameters and more are arranged in nested lists as illustrated by figure \ref{fig:MatrixFormat}. The end product of the translation process is made available as an \gls{api} endpoint, after retrieval as described previously, allowing for the retrieval of the model. The Teusink example can be found at \href{https://jjj.bio.vu.nl/rest/models/teusink/mf/} with additional resources to JWSOnline available at \href{http://jws-docs.readthedocs.io/8_rest.html}{JWS Docs}.

\subsection{Data Sorting (B)}
Once all available models have been retrieved to the local repository the mf version was requested as mentioned in section \ref{Translation}. These models were then sent for sorting and handling (3.). A process that starts off by exporting the model name to a log file for tracking. All divergences of the model flow path will be capture within this log file towards a representation of model flow in the form of a directed graph. Vertices were defined as model and reaction names as well as endpoints specified. Edges in turn represent the relationships and direction of procedural flow. Figure is the end result of this log file. This will be discussed further in the results section. 

After the initialisation step, the model is then sent to the check model function (4.). This function examines the semantic structures as well as behaviour of models, in order to identify suitable models for the analysis at hand. The first process evaluates whether or not a model contains event functions, by matching the pattern of an empty list to the appropriate sub list in the model (5.). A successful model is then checked for the presence of stoichiometry (6.) by testing whether or not the stoichiometry list contains data. In other words, when the length of the list at the stoichiometry index is equal to zero, the model contains no stoichiometry and is handled and logged as such. Model event triggers, such as described above, can also be specified in terms of piecewise functions (7.). As no a priori knowledge on the timing or the effect of these event triggers upon the steady state and control behaviour were available, they were also identified and logged. These steps served as an minimal-validation for initial useful models. As these procedures are not as computationally intensive as simulation operations, they were placed first in the order of operation in order to speed up the computation time. 

Following the semantic and structural tests described above, the stability of a model was assessed by evaluating steady state behaviour. For this purpose the Jacobian matrix was consulted (8.). As is known from linear algebra, the eigenvalues of a Jacobian matrix holds information on the stability of a system of ODE's. The system converges to a stable state when a decrease in perturbation is observed, in other words the real parts of the eigenvalues are negative pointing to a decrease in initial perturbations. In contrast a positive eigenvalue points to a divergence from a stable state, as a perturbation is increased and amplified. A third condition is the occurrence of a positive eigenvalue with a non zero imaginary part. These results are indicative of a system oscillating around some state, be it stable or unstable periodic behaviour. As such, model names exhibiting oscillatory behaviour were identified and written to our log file. A model that have reached this point was then written, in full mf form, to text file for the record and future use. The model is then sent for the simulation and calculation procedures as described next.

\subsection{Calculations (C)} \label{Calculations}
The \gls{steady-state} of a model was calculated and the flux control coefficients were determined (2.). This was done utilizing linear algebra methods as described by \citeauthor{Hofmeyr2001}. Models containing negative flux control coefficients were identified and logged. As disequilibrium ratio calculations are only applicable to reactions proceeding in a reversible manner, a test function was developed. A reversible reaction was defined as a rate equation containing a negative part within the numerator portion, thus allowing a rate to become negative (reversible) under appropriate conditions. The numerator is therefore recast into base components and tested for the presence of a negative-one term (3.). This was achieved by utilising the tree form structures available to Mathematica leading to an equation expanded into smallest parts. The position of these reactions were then stored in a variable for use in disequilibrium calculations later. 

Flux controls were calculated from elasticities as well as concentration control coe\"fficients. Concentration control coe\"fficients in turn being calculated from the inverse of Jacobian matrices as defined by \citeauthor{Hofmeyr2001}. Therefore, as the Jacobian approaches values close to zero, the inverse approaches infinity. This introduced errors due to machine precision digit and accuracy limitations. As such a further step in ensuring model validity was implemented via elasticity calculations (4.). Maximum elasticity values of the system were then compared to a threshold, chosen as $1 \cdot 10^{-10}$. The choice of this threshold was based on observation of failed calculations from models in a "trial and error manner".  Models surpassing this threshold was passed to the following step (5.). 

To calculate disequilibrium ratios, knowledge of metabolite identity (substrate/product) was needed. Metabolites were identified through the use of the stoichiometry matrix. One can extract products and substrates on the basis of stoichiometry values that are larger or smaller than zero respectively(6.). Returning a reaction id linked to product id allowed for the consistent handling of applicable reactions. In the case of multiple products only the first product was returned for use, more were not requi. Once products have been identified, gamma is determined by raising each metabolite in a reaction to the power of it's corresponding stoichiometry, leading to the first part of symbolic gamma construction. For second part, each of these exponents were multiplied by one another according to the respective reaction rows. The result is a symbolic construction of gamma ratios. 

For the following step, $K_{eq}$ calculations, equalities were defined in terms of equilibrium, \textit{i.e.} the rate equation equalling zero. Following, the equality was symbolically solved in terms of the product identified in (6.). This was achieved by utilising the "Solve" function in Mathematica.





\section{Analysis} \label{Analysis}
